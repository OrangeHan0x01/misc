import numpy as np
nmicro = 6
layers = 1
micros_every_layer = 6
R = [0.082]
theta_micro = np.zeros(nmicro)
theta_micro = 2*np.pi/micros_every_layer*(np.arange(micros_every_layer)+0.5*layers)
pos = np.stack([R[0] * np.cos(theta_micro[:6]), R[0] * np.sin(theta_micro[:6]), np.zeros(6)],axis = 1)
#最后求得的声源位置
theta = np.arange(-180, 180, 0.2).reshape([1, -1])#用角度代替x,y坐标，shape(1,1800)
theta_0 = theta/180 * np.pi#观察方向的弧度

def beamforming():
    fig, ax = plt.subplots(1, 1, sharex=True, sharey=False, figsize=(7, 2), dpi=300)
    while True:
        data = stream.read(1600)#0.1秒的数据？
        data = np.frombuffer(data, dtype=np.short)
        data = data.reshape(1600,8)[:,:6].T
        sigma = []#声强谱矩阵
        #傅里叶变换，在频域进行检测
        data_n = np.fft.fft(data)/data.shape[1]# [16,1600]，shape[1]读取第二个维度的大小，即列数，这里生成fft频谱之后
        ndata_n = data_n
        data_n = data_n[:, :data.shape[1]//2]#每行只取前一半元素
        data_n[:, 1:] *= 2#除了元素0，均乘以2
        #宽带处理，对于50个不同的频率都进行计算
        #r存储每个频率下对应信号的R矩阵，即其协方差矩阵
        r = np.zeros((50, nmicro, nmicro), dtype=np.complex)
        for fi in range(1,51):#fi是phi
            rr = np.dot(data_n[:, fi*10-10:fi*10+10], data_n[:, fi*10-10:fi*10+10].T.conjugate())/nmicro#np.dot:矩阵点积，.T求转置，.conjugate求共轭，最后归一化。获取fi*10-10~+10这20行的数据
            r[fi-1,...] = np.linalg.inv(rr)#矩阵求逆，linalg.det是矩阵求行列式，这里是求出协方差矩阵吧
        #MVDR搜索过程,可以考虑不再使用x,y的值，
        for i in range(theta.shape[1]):
                delta_dn=R[0]*np.cos(n*np.pi/3-theta_0[:, i])#这里的np.pi/3是因为有6个麦克风，所以360/6=60度=np.pi/3~
                for fi in range(1,51):
                    a = np.exp(-1j*2*np.pi*fi*100*delta_dn/340)#计算方向响应向量a(theta)
                    if fi == 1:
                        sigma.append( 1/np.abs(np.dot(np.dot(a.conjugate(), r[fi-1]), a))#这是按照另一个公式计算的，r[fi-1]是phi相关的。跳过了w.H,这里W=phi_inv * a / (a.H * r[fi-1] * a)(按顺序),波束响应B = w.H * a就算是最终的信号了
                    else:
                        sigma[i]=sigma[i]+(1/np.abs(np.dot(np.dot(a.conjugate(), r[fi-1]), a))#sigma是以i为坐标
#但是，这里的p矩阵好像会随着mvdr的x、y循环而不断增加（功率谱确实如此）
                    if((i*0.2-180)==120):#这里观察角度为120度
                        w = np.dot(r[fi-1] , a)/np.dot(np.dot(a.conjugate(), r[fi-1]), a)
                        B=w.H * a
#y的部分依然不确定，尤其是：1、需要什么乘法形式（应该是矩阵乘法） 2、y的格式怎么进行逆fft3、频域转时域
                        y=B*ndata_n#乘以ndata_n，但注意B是从w和a中来的，考虑两者会不会形状不同
                        y=np.abs(np.fft.ifft(y))#这是观察角度下固定频率的y输出，真正的数据应该把这些加总。注意只要某个观察角度下的。
                        if(fi==1):
                            y0=y
                        else:
                            y0=y0+y
#B还是和频率相关的，每个频率有各自的波束响应向量，这里频域结果应该还要还原到时域
#不同频率数据还原到值域后应该可以再加总
#B与数据相乘，应该是与theta.shape(1800)相同，将每列数据（麦克风已知角度）乘以B的对应角度的值最后加和，应该可以得到想要的输出y
        sigma = np.array(sigma).reshape([-1, 1])
        #绘制声强图
        ax[0].plot(theta_0.reshape([-1,1])*180/np.pi, 10 * np.log10(sigma))
        plt.show()
